<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL 3D Pyramid - 720p @ 60fps</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="glCanvas" width="1280" height="720"></canvas> <!-- 720p Resolution -->

    <script>
        const vsSource = `
      attribute vec4 position;
      attribute vec4 color;
      uniform mat4 projectionMatrix;
      uniform mat4 modelViewMatrix;
      varying lowp vec4 vColor;
      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * position;
        vColor = color;
      }
    `;

        const fsSource = `
      varying lowp vec4 vColor;
      void main() {
        gl_FragColor = vColor;
      }
    `;

        function initWebGL() {
            const canvas = document.getElementById("glCanvas");
            const gl = canvas.getContext("webgl");

            if (!gl) {
                alert("Unable to initialize WebGL.");
                return null;
            }

            const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Shader program failed to link.");
                return null;
            }

            gl.useProgram(shaderProgram);

            return { gl, shaderProgram };
        }

        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert("Shader compilation failed.");
                return null;
            }

            return shader;
        }

        function initBuffers(gl) {
            const vertices = new Float32Array([
                // Tip of the pyramid
                0.0, 1.0, 0.0,   // Vertex 0: tip

                // Base of the pyramid (square)
                -1.0, -1.0, 1.0,   // Vertex 1: front-left
                1.0, -1.0, 1.0,   // Vertex 2: front-right
                1.0, -1.0, -1.0,   // Vertex 3: back-right
                -1.0, -1.0, -1.0    // Vertex 4: back-left
            ]);

            const indices = new Uint16Array([
                // Pyramid sides (triangles)
                0, 1, 2,    // Front face
                0, 2, 3,    // Right face
                0, 3, 4,    // Back face
                0, 4, 1     // Left face
            ]);

            const colors = new Float32Array([
                // Tip color (soft pastel)
                0.8, 0.8, 1.0, 1.0,  // Light blue

                // Base colors (softer tones)
                0.9, 0.5, 0.7, 1.0,  // Light pink (front-left)
                0.5, 0.9, 0.5, 1.0,  // Light green (front-right)
                0.5, 0.5, 0.9, 1.0,  // Light blue (back-right)
                0.9, 0.8, 0.5, 1.0   // Light yellow (back-left)
            ]);

            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            return {
                vertexBuffer,
                colorBuffer,
                indexBuffer
            };
        }

        function drawScene(gl, shaderProgram, buffers, rotation) {
            const fieldOfView = 45 * Math.PI / 180;
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 100.0;

            const projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

            const modelViewMatrix = mat4.create();
            mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -6.0]);

            // Apply rotation around the Y axis
            mat4.rotate(modelViewMatrix, modelViewMatrix, rotation, [0, 1, 0]);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertexBuffer);
            const position = gl.getAttribLocation(shaderProgram, "position");
            gl.vertexAttribPointer(position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(position);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.colorBuffer);
            const color = gl.getAttribLocation(shaderProgram, "color");
            gl.vertexAttribPointer(color, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(color);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indexBuffer);

            const projectionMatrixUniform = gl.getUniformLocation(shaderProgram, "projectionMatrix");
            const modelViewMatrixUniform = gl.getUniformLocation(shaderProgram, "modelViewMatrix");

            gl.uniformMatrix4fv(projectionMatrixUniform, false, projectionMatrix);
            gl.uniformMatrix4fv(modelViewMatrixUniform, false, modelViewMatrix);

            gl.drawElements(gl.TRIANGLES, 12, gl.UNSIGNED_SHORT, 0);
        }

        function main() {
            const { gl, shaderProgram } = initWebGL();
            const buffers = initBuffers(gl);

            let rotation = 0.0;

            function render() {
                rotation += 0.005;  // Slower rotation
                drawScene(gl, shaderProgram, buffers, rotation);
                setTimeout(() => requestAnimationFrame(render), 1000 / 60); // 60 FPS
            }

            // Set background to black and start rendering loop
            gl.clearColor(0.0, 0.0, 0.0, 1.0); // Black background
            render();
        }

        window.onload = main;
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
</body>

</html>
